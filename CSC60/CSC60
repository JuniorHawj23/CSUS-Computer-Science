# Brian Hert Lab 10 part 2

CC = gcc
lab10: lab10.o ParseCmd.o ProcessExtCmd.o Redirect.o RunExtCmd.o
	gcc lab10.o ParseCmd.o ProcessExtCmd.o Redirect.o RunExtCmd.o -o lab10
	
lab10.o: lab10.c lab9_10.h
	gcc -c lab10.c -Wall
	
ParseCmd.o: ParseCmd.c lab9_10.h
	gcc -c ParseCmd.c -Wall
	
ProcessExtCmd.o: ProcessExtCmd.c lab9_10.h
	gcc -c ProcessExtCmd.c -Wall
	
Redirct.o: Redirect.c lab9_10.h
	gcc -c Redirect.c -Wall
	
RunExtCmd.o: RunExtCmd.c lab9_10.h
	gcc -c RunExtCmd.c -Wall

# Brian Hert Lab 8 Structs
# You need to add the code here for get_stats.c

CC = gcc
lab8: lab8.o get_data.o open_out_file.o print_all.o get_stats.o lab8.h
	gcc lab8.o get_data.o open_out_file.o print_all.o get_stats.o -o lab8 
   
lab8.o: lab8.c lab8.h
	gcc -c lab8.c 
	
get_data.o: get_data.c lab8.h	
	gcc -c get_data.c
	
open_out_file.o: open_out_file.c lab8.h
	gcc -c open_out_file.c
	
print_all.o: print_all.c lab8.h
	gcc -c print_all.c
	
get_stats.o: get_stats.c lab8.h
	gcc -c get_stats.c

/*----------------------------------------------------------*/
/* Brian Hert                                               */
/* This function will open the output file and return the   */
/* file pointer name to the main program.                   */

#include "lab8.h"

FILE * open_out_file (void)
{
    FILE * outfile;

    outfile = fopen(OUT_FILENAME, "w");
    if (outfile == NULL)
    {
        printf("Error on fopen of %s \n", OUT_FILENAME);
        exit(EXIT_FAILURE);
    }
    fprintf(outfile, "\nBrian Hert, Lab 8 output. \n");

    return outfile;
}

/*-----------------------------------------------------------*/

/*-------------------------------------------------------------*/
/* This function will print all but your name (which is above) */

#include "lab7.h"

void print_all( const char *filename, /* input, the current filename */
    int real_filesize, /* input, actual size of the data */
    int *range_count) /* input, # of values in range */
{
    int d;

    printf("\nBrian Hert. Lab 7. \n");
    printf("\nFile %s: ", filename);
    printf("\nThere are %i values in the range of 90 through 99\n",*range_count);
    printf("out of a total of %i values.", real_filesize);

    printf("\n\n");

    return;
}
/*-----------------------------------------------------------------*/

/* Author(s): Brian Hert

/* ----------------------------------------------------------------- */
/*                  Redirect, part of a child process                */
/* ----------------------------------------------------------------- */

#include "lab9_10.h"
#include<stdlib.h>
#include<unistd.h>
#include<stdio.h>
#include<fcntl.h>

void Redirect(int argc, char *argv[])
{
    int i;        // loop counter
    int out = 0;  // track position of location Out redirection, >
    int in = 0;   // track position of location In redirection, <
    int fd;

    for(i=0; i<argc; i++) 
    {
        if(strcmp(argv[i], ">")==0) 
        {
            if(out != 0) 
            {
                fprintf(stderr, "Cannot output to more than one file.\n");
                _exit(EXIT_FAILURE);
            }
            else if(i==0) 
            {
                fprintf(stderr, "No command entered.\n");
                _exit(EXIT_FAILURE);
            } 
            out = i;
        }
        else if(strcmp(argv[i],"<")==0) 
        {
            if(in != 0) 
            {
                fprintf(stderr, "Cannot input to more than one file.\n");
                _exit(EXIT_FAILURE);
            }
            else if(i==0) {
                fprintf(stderr, "No command entered.\n");
                _exit(EXIT_FAILURE);
            }
            in = i;
        }
    }

    if(out !=0) {
        if(argv[out+1] == '\0') {
            fprintf(stderr, "There is no file.\n");
            _exit(EXIT_FAILURE);
        }
        fd = open(argv[out+1], O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
        if(fd==-1){
            fprintf(stderr, "Cannot open/create file./n");
            _exit(EXIT_FAILURE);
        }
        dup2(fd, 1);
        if(close(fd) == -1) { 
            perror("Error closing file\n");
            _exit(EXIT_FAILURE);
        }      
        argv[out] = NULL;
    } 
    if(in != 0)
    {
        if(argv[in + 1] == NULL)
        {
            fprintf(stderr, "No file specified.\n");
            _exit(EXIT_FAILURE);
        }
        fd = open(argv[in+1], O_RDONLY);
        if(fd==-1)
        {
            fprintf(stderr, "Cannot open/create file.\n");
            _exit(EXIT_FAILURE);
        }
        dup2(fd, 0);
        if( close(fd) == -1)
        {
            perror("Error closing file\n");
            exit(EXIT_FAILURE);
        }
        argv[in] = NULL;
    }
}

/*end of function*/


/* ----------------------------------------------------------------- */
/*                 RunExtCmd                            CLASS        */
/*------------------------------------------------------------------ */
// Brian Hert

#include "lab9_10.h"

void RunExtCmd(int argc, char **argv) 
{                             
    // int ret;
    //Add the call to the function Redirect

    Redirect(argc, argv);

    // Add the call to execvp

    int ret = execvp(argv[0], argv);
    
    if (ret == -1)    // error check for the exec call
    {                                       
        fprintf(stderr, "Error on the exec call\n");             
        _exit(EXIT_FAILURE);                                   
    }                                                         
                                                          
    return;
}
/* ----------------------------------------------------------------- */

/*--------------------------------------------------------------*/
// Brian Hert
void get_range_count(int number_list[], int real_filesize, int *range_count) {

    *range_count = 0;

    int i;
    for(i = 0; i < real_filesize; i++) {
        if((number_list[i] >= 90) && (number_list[i] <= 99))
            (*range_count)++;
    }

return;

}

/*---------------------------------------------------------------*/

/*-------------------------------------------------------------------*/
/* Brian Hert                                                        */ 
/* Ruthann Biel                                                      */
/* get_stats_me is a function to do figure the best throw for each   */
/* thrower, compute the all-over average of the best throws, and     */
/* find the longest throw  on the track and each thrower's deviation */
/* from the winning throw                                            */

#include "lab8.h"

void get_stats(thrower_t throw_list[NCOMPETITORS], /* in & out */
        stats_t *throw_stats)           	       /* output   */
{ 

    int r,c;

    throw_stats->average_of_best_throws = 0;
    throw_stats->winning_throw = 0;

    for(r=0; r<NCOMPETITORS; r++) {

        throw_list[r].best_throw = throw_list[r].tries[0];
        for(c=1; c<N_TRIES; c++) {

            if(throw_list[r].tries[c] > throw_list[r].best_throw)  
                throw_list[r].best_throw = throw_list[r].tries[c];
        }

        throw_stats -> average_of_best_throws += throw_list[r].best_throw;

            if(throw_stats -> winning_throw < throw_list[r].best_throw) 
                throw_stats -> winning_throw = throw_list[r].best_throw;
        
         }
        
        for(r=0; r<NCOMPETITORS; r++) {

            throw_list[r].deviation = throw_stats->winning_throw - throw_list[r].best_throw;
        }

        throw_stats -> average_of_best_throws /= NCOMPETITORS;

        return; 
} 
/*--------------------------------------------------------*/

/* ---------- */
/* Brian Hert */
/* Lab 2 */ 

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    printf("\nLab 2. \n\n");
    printf("Hello World.\n");
    printf("Hi, Brian Hert. \n\n");
    printf("Be Better Than You Were Yesterday. \n-Lorenzo Snow\n\n");

    return EXIT_SUCCESS;
}
/*------------------------*/

/*--------------------------------------------*/
/* Brian Hert                                 */
/* Lab 5                                      */
/* Figure the area of a parabola using files  */

#include <stdio.h>
#include <stdlib.h>

#define IN_FILE_NAME "lab5.dat"
#define OUT_FILE_NAME "lab5.txt"

int main(void) {
    double length, depth, area;
    FILE *infile = fopen(IN_FILE_NAME, "r");
    FILE *outfile = fopen(OUT_FILE_NAME, "w+");

    fprintf(outfile, "\nBrian Hert. Lab 5. \n\n");
    fprintf(outfile, "Data on Parabolas \n\n");
    fprintf(outfile, "  Length      Depth     Area\n");
    fprintf(outfile, " --------   --------   ---------\n");
                               
    while((fscanf(infile, "%lf%lf" ,&length,&depth)) == 2) {
      area = 2*length*depth/3;
      fprintf(outfile,"%7.2lf     %7.2lf  %10.31f\n",length,depth,area);
      
    }

    fprintf(outfile, "\n\n");
    
    fclose(infile);
    fclose(outfile);
    return EXIT_SUCCESS;
}
/*-------------------------------------------------*/
/*  Brian Hert                              */
/*  lab8.h - Olympic woman's javelin throw  */  

#define NCOMPETITORS 4
#define N_TRIES 4

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OUT_FILENAME "lab8.txt"
//#define OUT_FILENAME "lab8sample.out"

#define IN_FILENAME "lab8.dat"
//#define IN_FILENAME "lab8sample.dat"

// ADD the two structs required: thrower_t and stats_t.

// struct #1 thrower
typedef struct {
    char name[20];
    double tries[N_TRIES];
    double best_throw;
    double deviation;
}thrower_t;

// struct #2 stats
typedef struct {
    double average_of_best_throws;
    double winning_throw;
}stats_t; 


/* FUNCTION PROTOTYPES */
/* get_data is a function to get and read data */
void get_data (char *filename,                              /* input  */ 
        thrower_t throw_list[NCOMPETITORS]);                        /* output */

/* open_out_file is a function to open the output file */
FILE * open_out_file (void);

/* get_stats is a function to do figure the best throw for each      */
/* thrower, compute the all-over average of the best throws, and     */
/* find the longest throw  on the track and each thrower's deviation */
/* from that winning long throw                                      */
// print_all is a function to print things out.

void get_stats(thrower_t throw_list[NCOMPETITORS],        /* in & out */
        stats_t *throw_stats);                        /* output   */

void print_all(FILE * out_file, 
        thrower_t throw_list[NCOMPETITORS],
        stats_t *throw_stats);       

/* Author(s): Ruthann Biel & Brian Hert
 * This is csc60mshell.c
 * This is program services as the base for doing labs 9 and 10.
 * Student is required to use this program to build a mini shell
 * using the specification as documented in the directions.
 * Date: Spring 2023
 */

# include "lab9_10.h"

/* --------------------------------------------------------------------- */
/*                      The main program starts here                     */
/*                                                                       */

int main(void)
{
    char cmdLine[MAXLINE];
    char *argv[MAXARGS];
    int argc;

    // Loop forever to wait and process commands
    while (TRUE)
    {
        printf("\ncsc60msh > ");

        /* read the command the user types in */
        fgets(cmdLine, MAXLINE, stdin);

        /* Call ParseCmd to build argc/argv; their limits declared in lab9_10.h */
        // You write this call.
        argc = ParseCmd(cmdLine, argv);

        // REQUIRED: Just-to-make sure printfs
        printf("Argc = %i \n", argc);
        int i;
        for(i = 0; i < argc; i++)
        {
            printf("Argv %i = %s \n",i,argv[i]);
        }

        // If user hits enter key without a command, continue to loop again at the begining
        if(argc==0)
        {
            continue;
        }

        if (strcmp(argv[0], "exit") == 0)
        {
            exit(EXIT_SUCCESS);
        }
        else if (strcmp(argv[0], "pwd") == 0)
        {
            char path[MAX_PATH_LENGTH];
            getcwd(path,MAX_PATH_LENGTH);
            printf("\nThe path is: %s", path); 
        }

        // You write this line. Hint if argc is zero, no command declared */
        else if (strcmp(argv[0], "cd") == 0)
        {
            // Handle build-in commands: exit, pwd, or cd
            // See the directions for the algorithms to do these 3 commands.
            char *dir;
            if(argc==1)
            {
                dir = getenv("HOME");
            }
            else
            {
                dir = (argv[1]);
            }
            if(chdir(dir) != 0)
            {
                printf("\n error changing directory");
                exit(EXIT_FAILURE);
            }
        }
        else
        {
            /* Else, fork off a process */
            // RunExtCmd(int argc, char argv);
        }
    }
}


// The header file for lab 9 & 10

/* The include files section */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

/* Define Section */
#define MAXLINE 80
#define MAXARGS 20
#define MAX_PATH_LENGTH 50
#define TRUE 1

/* function prototypes */
int  ParseCmd(char *cmdLine, char **argv);
void ProcessExtCmd(int argc, char **argv); 
void Redirect(int argc, char **argv); 
void RunExtCmd(int argc, char **argv);


/* Author(s): Brian Hert 
 * This is csc60mshell.c
 * This is program services as the base for doing labs 9 and 10.
 * Student is required to use this program to build a mini shell
 * using the specification as documented in the directions.
 * Date: Spring 2023     
 */

# include "lab9_10.h"

/* --------------------------------------------------------------------- */
/*                      The main program starts here                     */
/*                                                                       */
int main(void)
{
    char cmdLine[MAXLINE];
    char *argv[MAXARGS];
    int argc;

    while (TRUE)
    {
        printf("\ncsc60msh > ");

        /* read the command the user types in */
        fgets(cmdLine, MAXLINE, stdin);

        /* Call ParseCmd to build argc/argv; their limits declared in lab9_10.h */
        // You write this call
        argc = ParseCmd(cmdLine, argv);

        // REQUIRED: Just-to-make sure printfs 
        printf("Argc = %i \n", argc);
        int i;
        for(i = 0; i < argc; i++)
        {
            printf("Argv %i = %s \n",i,argv[i]);
        }

        // If user hits enter key without a command, continue to loop again at the begining 
        if(argc==0) 
        {
        continue;
        }

        if (strcmp(argv[0], "exit") == 0)
        {
            exit(EXIT_SUCCESS);
        }
        else if (strcmp(argv[0], "pwd") == 0)
        {
            char path[MAX_PATH_LENGTH];
            getcwd(path,MAX_PATH_LENGTH);
            printf("\nThe path is: %s", path);
        }

        // You write this line. Hint if argc is zero, no command declared
        else if(strcmp(argv[0], "cd") == 0)
        {
            // Handle build-in commands; exit, pwd, or cd
            // See the directions for the algorithms to do these 3 commands.
            char *dir;
            if(argc==1)
            {
                dir = getenv("HOME");
            }
            else
            {
                dir = (argv[1]);
            }
            if(chdir(dir) < 0) 
            {
                printf("\n error changing directory");
    
            }
        }

        else
        {
            /* Else, fork off a process */
            ProcessExtCmd( argc, argv);
        }
    }
}
